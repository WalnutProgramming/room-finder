/// <reference path="../external-types/dijkstra.d.ts" />
import dijkstra from "dijkstrajs";
import { ForkNode, reverseConnection } from "./ForkNode";
import { StairNode, onFloor } from "./StairNode";
import { serializeNode, nodeFromString, Node } from "./node";
import { OneWay } from "./Hallway";
import { StairOneWay } from "./StairOneWay";

export type HallConnectorsStructures<
  ForkName extends string,
  StairName extends string
> = {
  nodes: {
    nodeId: Node<ForkName, StairName>;
    edgeLengthFromPreviousNodeInHallway: number;
  }[];
  oneWay: OneWay;
}[];

/**
 * @ignore
 */
function getHallwayConnections<
  ForkName extends string,
  StairName extends string
>(
  hallConnections: HallConnectorsStructures<ForkName, StairName>
): [string, string][] {
  return hallConnections
    .map(hallway => hallway.nodes)
    .flat()
    .map(thing => thing.nodeId)
    .filter(
      (connection): connection is ForkNode<ForkName> =>
        connection instanceof ForkNode
    )
    .filter(connection => !connection.reversed)
    .map(forkNode => [
      serializeNode(forkNode),
      serializeNode(reverseConnection(forkNode.name)),
    ]);
}

/** @ignore */
function getStairConnections<ForkName extends string, StairName extends string>(
  hallConnections: HallConnectorsStructures<ForkName, StairName>,
  oneWayStaircases: Partial<Record<StairName, StairOneWay>>
): { floors: string[]; oneWay: StairOneWay }[] {
  const stairNodes = hallConnections
    .map(hallway => hallway.nodes)
    .flat()
    .map(thing => thing.nodeId)
    .filter((st): st is StairNode<StairName> => st instanceof StairNode);
  const staircases = [...new Set(stairNodes.map(node => node.name))];
  return staircases.map(name => ({
    floors: stairNodes
      .filter(node => node.name === name)
      .sort((a, b) => b.floor - a.floor)
      .map(serializeNode),
    oneWay: oneWayStaircases[name] ?? false,
  }));
}

/**
 * @ignore
 * @param hallConnectors - an array of each hallway's array of nodes
 * @param stairConnections - an array of stairs, where each stair has
 * a list of nodes going from the top to the bottom
 * @param hallwayConnections - an array of the pairs of connected hallway nodes
 * @returns The graph to be used by getShortestPath
 */
export function getGraph<ForkName extends string, StairName extends string>(
  hallConnectorsStructures: HallConnectorsStructures<ForkName, StairName>,
  oneWayStaircases: Partial<Record<StairName, StairOneWay>>
) {
  const hallConnectors = hallConnectorsStructures.map(hall => ({
    oneWay: hall.oneWay,
    nodes: hall.nodes.map(
      ({ nodeId, edgeLengthFromPreviousNodeInHallway }) => ({
        nodeId: serializeNode(nodeId),
        edgeLengthFromPreviousNodeInHallway,
      })
    ),
  }));
  const stairConnections = getStairConnections(
    hallConnectorsStructures,
    oneWayStaircases
  );
  const hallwayConnections = getHallwayConnections(hallConnectorsStructures);

  const graph: dijkstra.Graph = {};
  hallConnectors.forEach(({ oneWay, nodes: hall }) => {
    hall.forEach((node, ind) => {
      const id = node.nodeId;
      const edgesTo: { [key: string]: number } = {};
      if (ind !== 0 && oneWay !== "forward") {
        edgesTo[hall[ind - 1].nodeId] =
          hall[ind].edgeLengthFromPreviousNodeInHallway;
      }
      if (ind !== hall.length - 1 && oneWay !== "backward") {
        edgesTo[hall[ind + 1].nodeId] =
          hall[ind + 1].edgeLengthFromPreviousNodeInHallway;
      }
      stairConnections.forEach(staircase => {
        const stairList = staircase.floors;
        const myFloorNum = stairList.indexOf(id);
        if (myFloorNum !== -1) {
          stairList.forEach((otherId, otherFloorNum) => {
            if (otherId === id) return;

            // I feel like the next lines should have ">" and "<" switched, but
            // the results seem to be wrong that way.
            if (staircase.oneWay === "up" && otherFloorNum > myFloorNum) return;
            if (staircase.oneWay === "down" && otherFloorNum < myFloorNum)
              return;

            const diff = Math.abs(myFloorNum - otherFloorNum);
            // We set the weight to slightly less than the number
            // of staircases we're going up because it's easier to go
            // up multiple stairs at once than to go up one flight, then
            // go to another set of stairs
            edgesTo[otherId] = diff * (1 - 0.001 * diff);
          });
        }
      });
      hallwayConnections.forEach(([bottom, top]) => {
        if (bottom === id) {
          edgesTo[top] = 1;
        } else if (top === id) {
          edgesTo[bottom] = 1;
        }
      });
      graph[id] = edgesTo;
    });
  });
  return graph;
}

/**
 * @ignore
 * @param graph - A graph generated by getGraph
 * @param idFrom - The id of the node to start at
 * @param idTo - The id of the destination node
 * @returns An array of node IDs that represents the path from `idFrom` to
 * `idTo`.
 */
export function getShortestPath<
  ForkName extends string,
  StairName extends string
>(
  graph: dijkstra.Graph,
  idFrom: Node<ForkName, StairName>,
  idTo: Node<ForkName, StairName>
): Node<ForkName, StairName>[] {
  return dijkstra
    .find_path(graph, serializeNode(idFrom), serializeNode(idTo))
    .map(nodeStr => nodeFromString(nodeStr));
}

/**
 * @ignore
 * @param graph - a graph
 * @returns - Is this a connected graph?
 */
export function isConnectedGraph(
  graph: dijkstra.Graph
): { connected: boolean; connectedSections: string[][] } {
  const nodeIdsWithDuplicates: string[] = [
    ...Object.keys(graph),
    ...Object.values(graph)
      .map(v => Object.keys(v))
      .flat(),
  ];

  const nodeIds: string[] = [...new Set(nodeIdsWithDuplicates)];

  if (nodeIds.length === 0) {
    return { connected: true, connectedSections: [] };
  }

  // https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm

  const nodeIdsVisited: string[] = [];
  const L: string[] = [];

  function visit(u: string) {
    if (!nodeIdsVisited.includes(u)) {
      nodeIdsVisited.push(u);
      const outNeigbors = graph[u] ? Object.keys(graph[u]) : [];
      for (const v of outNeigbors) {
        visit(v);
      }
      L.unshift(u);
    }
  }
  for (const u of nodeIds) {
    visit(u);
  }

  // key is the root
  const components: Record<string, string[]> = {};
  function assign(u: string, root: string) {
    const assignedValues = [
      ...Object.keys(components),
      ...Object.values(components).flat(),
    ];
    if (!assignedValues.includes(u)) {
      if (!Object.keys(components).includes(root)) components[root] = [];
      components[root].push(u);
      const inNeigbors = Object.keys(graph).filter(k =>
        Object.keys(graph[k]).includes(u)
      );
      for (const v of inNeigbors) {
        assign(v, root);
      }
    }
  }
  for (const u of L) {
    assign(u, u);
  }

  const flattenedComponents: string[][] = Object.entries(
    components
  ).map(([k, vals]) => [...new Set([k, ...vals])]);
  return {
    connected: flattenedComponents.length === 1,
    connectedSections: flattenedComponents,
  };

  // let traveled: string[] = [];
  // const travelOut = (nodeId: string) => {
  //   if (!traveled.includes(nodeId)) {
  //     traveled.push(nodeId);
  //     if (Object.keys(graph).includes(nodeId)) {
  //       for (const newNode of Object.keys(graph[nodeId])) {
  //         travelOut(newNode);
  //       }
  //     }
  //   }
  // };

  // const connectedSections: string[][] = [];
  // while (connectedSections.flat().length < nodeIds.length) {
  //   const nextUntraveledNodeId = nodeIds.find(
  //     s => !connectedSections.flat().includes(s)
  //   )!;
  //   traveled = [];
  //   travelOut(nextUntraveledNodeId);
  //   connectedSections.push(traveled);
  // }

  // return { connected: connectedSections.length === 1, connectedSections };
}
